# XORing Elepnahtsを読む

https://dl.acm.org/doi/10.14778/2535573.2488339

# この文書の目的
$(10, 4)$-RS符号という
+ 元データ$M$を各$\frac{M}{10}$サイズの$14$ブロックに分割し
+ 元データは$10$ブロックあれば回復でき
+ 各ブロックは$10$ブロックあれば回復できる

という性質のものから$(10, 6, 5)$-LRC符号という
+ 元データを$\frac{M}{10}$サイズの$16$ブロックに分割し
+ 元データは$10$ブロックあれば回復でき
+ 各ブロックは$5$ブロックあれば回復でいる

別の符号を具体的に作る。

総データ量は$16/14$なので$14\%$増えることになるが、
ブロックのロスト時のデータ転送量は$50\%$まで減らせる。

一般のRS符号からLRC符号を作る方法も述べられているが書かれている細かい証明が不安なので一旦後回し。

# Introduction
Motivationが色々書いているのですが、
ポジショントーク感が強くあってもなくてもいまいち
変わらないので飛ばします。

# Theoretical Contributions

$(k, n-k)$-MDSとは
* $M$サイズのデータを
* $k$個に等ブロック化し
* $n$個に符号化ブロックになる。

重要な性質は$n$個のうち、どれでも良いので$k$個の符号化ブロックが
残っていれば、元の$M$サイズのデータが復元できるというもの。

MDSはMaximum distance separableの略で
MDS符号化には幾つかあるが、Reed-Solomon符号が代表的である。

この論文でも主にこのRS符号を考える。

例として $2$-MBのデータの$(10, 4)$-RS符号化では:
* $\frac{2}{10}$-MBの14個の符号化ブロックが生成される。
* 14個のうち、任意の10符号化ブロックがあれば元の$2$-MBデータが復元できる。

幾つか言葉を導入する。

<b>Minimum Code Distance</b>: ある符号において、
それ以上符号化ブロックが消失すると、元データが復元できなくなる値。

例えば$(10, 4)$-RSのmcdは、4つまでは復元できるが5つ以上を失うと復元できなくなるので、$5$となる。

<b>Block Locality</b>: ある符号において、
1つの符号化ブロックを復元するのに最低限必要な符号化ブロック数。
（オリジナルの定義が意味不明なので、実際に必要な範囲に修正してます）

## MDSとBlock Localityを関連付ける性質
$(k, n-k)$-MDSのBlock Localityは$k$以上になる。

> 証明（論文にはないので勝手に書いてます）
>  $k-1$ノードを使ってあるノードを復元できたとする。
> このとき、手元には$k$ノードがあるため、元のデータが復元できる。
> すなわち$k-1$ノードから元データが復元できたことになるため
> MDSの定義に反する。

単純な性質ですが、MDSでは1ブロック欠けただけで
元データが本質的に復元必須となることを意味しています。

# $(k, n-k, r)$-LRC
オリジナルデータ復元に対して$n-k$程度失っても良いが、
ブロックのrepairについては$r < k$となるような$r$程度必要となる
新しい符号化を考えていきたい。

この論文は$(k, n-k, r)$-LRCという次の性質を持つ符号化を提案する
+ $r = \log(k)$
+ mdc が $n - (1 + \delta_k)k + 1$
    + すなわち $(1 + \delta_k)k$ だけデータが必要になる。
    + ただし $\delta_k = \frac{1}{\log(k)} - \frac{1}{k}$

$k$が十分大きくなれば（実践では厳しいが理論的な話としては）
$\delta_k$は0に近づくので、MDSに漸近的に近づいていく。

# 具体例: $(10, 6, 5)$-LRC
さて、オリジナルデータを復元するには10個の符号化ブロックが必要だが、
1つの符号化ブロックを復元するには5個の符号化ブロックが必要なLRCを
考える。

いきなり$5 \neq \log(10)$ですけど大丈夫ですかね……

まず$10$個のデータブロックに $X_1, X_2, \ldots, X_{10}$と
$4$個のparityブロックに $P_1, P_2, P_3, P_4$と名付ける。

更にlocal parityという2つのブロックをデータブロックから次のようにして定義する

$$
\begin{array}{l}
S_1 = c_1 X_1 + c_2 X_2 + c_3 X_3 + c_4 X_4 + c_5 X_5, \\
S_2 = c_6 X_6 + c_7 X_7 + c_8 X_8 + c_9 X_9 + c_{10} X_{10}.
\end{array}
$$

このlocal parityをどのようにして使うかだが、
まずデータブロック側で消失が発生した場合を考える。
例えば$X_3$のデータを復元することを考えると、$S_1$に参加している他のノードを集めて

$$
X_3 = c^{-1}_3 (S_1 - c_1 X_1 - c_2 X_2 - c_4 X_4 - c_5 X_5)
$$

とすれば良い。

$c_3$には逆元が存在しなければならないし、$c_i$達は線形独立となるように
選ばなければならないが、そのアルゴリズムも論文で具体的に与える。

次にparityブロック側 $P_2$ が消失した場合は

$$
P_2 = d^{-1}_2(-S_1 - S_2 - d_1 P_1 - d_3 P_3 - d_4 P_4)
$$

とする。

そのような$d$達が存在することも同様に保証しなければならないが、
これも可能である。

結局どのブロックを復元する際にも5ブロックへのアクセスで事足りるし、
元のデータが復元したい場合には$X_1, \ldots, X_10, P_1, P_2, P_3, P_4$の中から10個のブロックを集めてRS復元すれば良い。

純粋なRS符号化では14ブロック必要であったが、
ここでは16ブロック必要になることに注意されたい。
その代わり、ブロックのrepairは50%で済んでいる。

## 重大な注意
論文ではなぜか次の3節にまわされているが、
「複数のブロックが壊れている場合のrepairはどうするか」
という現実の問題を無視することはできない。

例えば、上の記号をそのまま使うとして$X_2$, $X_3$の2つのデータブロックが消失していたとする。
この時はどうしようもないので、
純粋なRSの方法により$X_2$と$X_3$を復元して配り直すしかない。
このプロセスを、3.1.2節では"Heavy-decoder"プロセスと呼んでいて、
単一ブロックの破損で5ブロックrepairできる場合を"Light-decoder"プロセスと呼んで区別している。

# $(10, 6, 5)$-LRCの具体的な構成
論文のAppendix Dをベースに書きます。

まず次のような $(n-k, n)$-行列 $\mathbb {H}$ を考えます:

$$
\mathbb{H} = \begin{pmatrix}
1 & 1 & \cdots & 1 \\
a_0 & a_1 & \cdots & a_{k-1} \\[5pt]
a^2_0 & a^2_1 & \cdots & a^2_{k-1} \\
 & & \vdots & \\
a^{n-k-1}_0 & a^{n-k-1}_1 & \cdots & a^{n-k-1}_{k-1}
\end{pmatrix}
$$

ただし$n \geq k$です。

この行列は高さ$n-k$の幅が$k$のいわゆるVandermonde型の行列です。

広く知られた性質としてこの行列中の任意の正方行列は逆行列を持つということがあります。
論文には「広く知られている」と単に書いてるんですが標準的な教科書で証明が与えられているなら明記したいです。正方行列版のVandermonde行列 $\mathbb{V}$の行列式が差積になる証明をほとんどそのまま適用できるかと思うんですが。

この$\mathbb{H}$をパリティ検査行列とする$(k, n)$生成行列$\mathbf{G}$とします。
パリティ検査行列から生成行列は符号理論の基本的な方法で構成できるので省略します。

この生成行列のminimum distanceが$n-k+1$すなわち$n-k$までのデータ消失に耐えられるということが、$\mathbb{H}$の任意の正方行列が逆行列を持つことから言えます（ちゃんと証明を書きたい）

後で使うので$\mathbf{G}$を次のように書いておきます:

$$
\mathbf{G} = \left( \mathbf{g}_1\ \mathbf{g}_2\ \ldots\  \mathbf{g}_{14} \right).
$$

$\mathbf{G}$を既にみたlocal parityを2列加えて次のように拡張します:

$$
\mathbf{G}_{\text{LRC}} = \left[  \mathbf{G} \bigg| \sum^5_{i=1} \mathbf{g}_i \sum^{10}_{i=6} \mathbf{g}_i \right].
$$

高さが10（＝行ベクトルが10本）で幅が16（=列ベクトルが16本）の行列になったことに注意してください。

また、$\mathbf{G}_{\text{LRC}}$はwlogでsystematic形式にできるのでそのようになっていると仮定します。すなわち

$$
\mathbf{G}_{\text{LRC}} = [ I_{10}; M_{(10, 4)} ]
$$

のように左側に単位行列が来るようにできます。$\mathbf{G}$の左側のサイズ10正方行列が逆行列を持つことを利用すれば直ちにできます。
このようにしておくと、生成行列として使った際にデータが直接出力されるので便利ということもあります。

### Block Localityが5の証明
これを示すには、$\mathbf{G}_{\text{LRC}}$の任意の列ベクトルが、5本の列ベクトルの線形結合で表せることを示せば十分です。

$\mathbf{g}_1, \ldots, \mathbf{g}_5$のどれかを復元することを考えます。具体的に$\mathbf{g}_1$を考えると、これは

$$
\mathbf{g}_1 = \left(\sum^5_{i=1}\mathbf{g}_i\right) - \mathbf{g}_2 - \mathbf{g}_3 - \mathbf{g}_4 - \mathbf{g}_5
$$

から明らかです。

$\mathbf{g}_6, \ldots, \mathbf{g}_{10}$についても同様にすれば良いです。

2つのlocal parity列ベクトルは定義から明らかで、問題になるのはparity列ベクトルとでも言うべき$\mathbf{g}_{11}, \mathbf{g}_{12}, \mathbf{g}_{13}, \mathbf{g}_{14}$の復元です。
どれも同じやり方で出来るので$\mathbf{g}_11$を具体的に考えます。

生成行列$\mathbf{G}$に関する次の基本性質を用います
+ パリティ検査行列$\mathbf{H}$について$\mathbf{G} \mathbf{H}^T = \mathbf{0}_{(k, n-k)}$が成立する
    + これは符号理論では非常に基本的な性質
+ 特に今回は$\mathbf{H}$の定義より

    $$
\mathbf{H}^T = \begin{pmatrix}
1 & \cdots \\
1 & \cdots \\
\vdots \\
1 & \cdots
\end{pmatrix}
$$

    となっているから$\mathbf{G}\mathbf{1}^T = \mathbf{0}_{(k, 1)}$が成立する。
+ 一般の行列の性質で

    $$
\mathbf{G} \mathbf{1}^T = \sum^{14}_{i=1} \mathbf{g}_i
$$

これらを合わせると

$$
\mathbf{g}_{11} = -\mathbf{\ell}_1 - \mathbf{\ell}_2 - \mathbf{g}_{12} - \mathbf{g}_{13} - \mathbf{g}_{14}
$$

として書ける。

よってBlock Localityが5になっていることは証明できた。

## minimum distance=5
ベースの符号化には$(10, 4)$-RSを用いていて、4つまでの消失には耐えられるからminimum distanceが5以上であることは分かる。

ここでは5つ消失すると復元できないことを具体的にみる。
論文の証明はgapがかなり大きそうなので、一般的に論じたい場合は線形代数の議論を使うかmin cutsetの議論を用いる必要があると思う。

$$
\mathbf{G}_{\text{LRC}} = ( \mathbf{g}_1\ \mathbf{g}_2\ \ldots \mathbf{g}_{14}\ \mathbf{\ell}_1\ \mathbf{\ell}_2 )
$$

のうち、

$$
\mathbf{g}_1, \mathbf{g}_2, \mathbf{g}_3, \mathbf{g}_4, \mathbf{g}_5
$$

の5つのデータベクトル相当が失われたときに元データが復元できると仮定して矛盾を導く。

これには

$$
\mathbf{g}_1 = c_1 \ell_1 + c_2 \ell_2 + c_6 \mathbf{g}_6 + \cdots + c_{10} \mathbf{g}_{10} + \cdots + c_{14} \mathbf{g}_{14}
$$

とするような係数達があると仮定して矛盾を導けば良い。

まず

\[
\ell_1 = -(\ell_2 + \mathbf{g}_{11} + \mathbf{g}_{12} + \mathbf{g}_{13} + \mathbf{g}_{14})
\]

であるから$\ell_1$を消去できる。

さらに $\ell_2 = \sum^{10}_{i=6}$ であるから $\ell_2$ も消去できる。

従って$\mathbf{g}_6, \mathbf{g}_7, \ldots, \mathbf{g}_{14}$の9本のベクトルで$\mathbf{g}_1$を復元できたことになり、ひいてはオリジナルデータも復元できる。
これは$\mathbf{G}$のminimum distanceが$5$であることに反するので、矛盾が示せた。
