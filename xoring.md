# XORing Elepnahtsを読む

# Introduction
Motivationが色々書いているのですが、
ポジショントーク感が強くあってもなくてもいまいち
変わらないので飛ばします。

# Theoretical Contributions

$(k, n-k)$-MDSとは
* $M$サイズのデータを
* $k$個に等ブロック化し
* $n$個に符号化ブロックになる。

重要な性質は$n$個のうち、どれでも良いので$k$個の符号化ブロックが
残っていれば、元の$M$サイズのデータが復元できるというもの。

MDSはMaximum distance separableの略で
MDS符号化には幾つかあるが、Reed-Solomon符号が代表的である。

この論文でも主にこのRS符号を考える。

例として $2$-MBのデータの$(10, 4)$-RS符号化では:
* $\frac{2}{10}$-MBの14個の符号化ブロックが生成される。
* 14個のうち、任意の10符号化ブロックがあれば元の$2$-MBデータが復元できる。

幾つか言葉を導入する。

<b>Minimum Code Distance</b>: ある符号において、
それ以上符号化ブロックが消失すると、元データが復元できなくなる値。

例えば$(10, 4)$-RSのmcdは、4つまでは復元できるが5つ以上を失うと復元できなくなるので、$5$となる。

<b>Block Locality</b>: ある符号において、
1つの符号化ブロックを復元するのに最低限必要な符号化ブロック数。
（オリジナルの定義が意味不明なので、実際に必要な範囲に修正してます）

## MDSとBlock Localityを関連付ける性質
$(k, n-k)$-MDSのBlock Localityは$k$以上になる。

> 証明（論文にはないので勝手に書いてます）
>  $k-1$ノードを使ってあるノードを復元できたとする。
> このとき、手元には$k$ノードがあるため、元のデータが復元できる。
> すなわち$k-1$ノードから元データが復元できたことになるため
> MDSの定義に反する。

単純な性質ですが、MDSでは1ブロック欠けただけで
元データが本質的に復元必須となることを意味しています。

# $(k, n-k, r)$-LRC
オリジナルデータ復元に対して$n-k$程度失っても良いが、
ブロックのrepairについては$r < k$となるような$r$程度必要となる
新しい符号化を考えていきたい。

この論文は$(k, n-k, r)$-LRCという次の性質を持つ符号化を提案する
+ $r = \log(k)$
+ mdc が $n - (1 + \delta_k)k + 1$
    + すなわち $(1 + \delta_k)k$ だけデータが必要になる。
    + ただし $\delta_k = \frac{1}{\log(k)} - \frac{1}{k}$

$k$が十分大きくなれば（実践では厳しいが理論的な話としては）
$\delta_k$は0に近づくので、MDSに漸近的に近づいていく。

# 具体例: $(10, 6, 5)$-LRC
さて、オリジナルデータを復元するには10個の符号化ブロックが必要だが、
1つの符号化ブロックを復元するには5個の符号化ブロックが必要なLRCを
考える。

いきなり$5 \neq \log(10)$ですけど大丈夫ですかね……

まず$10$個のデータブロックに $X_1, X_2, \ldots, X_{10}$と
$4$個のparityブロックに $P_1, P_2, P_3, P_4$と名付ける。

更にlocal parityという2つのブロックをデータブロックから次のようにして定義する
$$
\begin{array}{l}
S_1 = c_1 X_1 + c_2 X_2 + c_3 X_3 + c_4 X_4 + c_5 X_5, \\
S_2 = c_6 X_6 + c_7 X_7 + c_8 X_8 + c_9 X_9 + c_{10} X_{10}.
\end{array}
$$

このlocal parityをどのようにして使うかだが、
まずデータブロック側で消失が発生した場合を考える。
例えば$X_3$のデータを復元することを考えると、$S_1$に参加している他のノードを集めて
$$
X_3 = c^{-1}_3 (S_1 - c_1 X_1 - c_2 X_2 - c_4 X_4 - c_5 X_5)
$$
とすれば良い。

$c_3$には逆元が存在しなければならないし、$c_i$達は線形独立となるように
選ばなければならないが、そのアルゴリズムも論文で具体的に与える。

次にparityブロック側 $P_2$ が消失した場合は
$$
P_2 = d^{-1}_2(-S_1 - S_2 - d_1 P_1 - d_3 P_3 - d_4 P_4)
$$
とする。

そのような$d$達が存在することも同様に保証しなければならないが、
これも可能である。

結局どのブロックを復元する際にも5ブロックへのアクセスで事足りるし、
元のデータが復元したい場合には$X_1, \ldots, X_10, P_1, P_2, P_3, P_4$の中から10個のブロックを集めてRS復元すれば良い。

純粋なRS符号化では14ブロック必要であったが、
ここでは16ブロック必要になることに注意されたい。
その代わり、ブロックのrepairは50%で済んでいる。

### 重大な注意
論文ではなぜか次の3節にまわされているが、
「複数のブロックが壊れている場合のrepairはどうするか」
という現実の問題を無視することはできない。

例えば、上の記号をそのまま使うとして$X_2$, $X_3$の2つのデータブロックが消失していたとする。
この時はどうしようもないので、
純粋なRSの方法により$X_2$と$X_3$を復元して配り直すしかない。
このプロセスを、3.1.2節では"Heavy-decoder"プロセスと呼んでいて、
単一ブロックの破損で5ブロックrepairできる場合を"Light-decoder"プロセスと呼んで区別している。
